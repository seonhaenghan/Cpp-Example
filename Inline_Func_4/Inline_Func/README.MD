# 인라인 함수 

## 1. 인라인 함수란?
- 인라인 함수의 의미는 프로그램 코드라인 안르오 들어가 버린 함수를 의미함

## 2. 매크로 함수의 장점
- 매크로 함수의 대표적인 장점은 >> 일반적인 함수에 비해서 실행속도의 이점이 있다.
- 실행 속도가 빨라지는 이유를 비롯해 매크로 함수가 성능향상에 도움이 되는 상황들을 알고있다.
- 반면 매크로 함수의 단점은 정의하기가 어렵고 복잡한 함수를 매크로의 형태로 정의하는데 한계가 있다.

EX) macro 정의의 예
 #include <iostream>
 #define SQUARE(x)		((x)*(x))

 int main(void)
 {
	 std::cout<< SQUARE(5) <<std::endl;
	 return 0;
 }

- 위의 코드는 전처리 과정을 거치면 다음과 같이 변경됨

 #include <iostream>

 int main(void)
 {
	 std::cout<< ((5)*(5)) <<std::endl;
	 return 0;
 }

- 여기서 중요한 점은 함수의 몸체부분이 함수의 호출문을 대체했다는 점이다. 
- 위 예제와 같이 함수의 몸체부분이 함수호출 문장을 완전히 대체 했을 때 함수가 인라인화 되었다라고 표현한다.

## 3. C++ 기반의 인라인 함수 정의 
>> InlineFunc.cpp은 매크로 함수를 이용하지 않는, C++ 기반의 인라인 함수의 정의 방법을 보이고 있다.
- 매크로를 이용한 함수의 인라인화는 전처리기에 의해서 처리된다.
- 하지만 키워드 inline을 이용한 함수의 인라인회는 컴파일러에 의해 처리된다.
- 따라서 컴파일러는 함수의 인라인화가 오히려 성능에 해가 된다고 판단할 경우
- 이 키워드를 무시해버리기도 한다.
- 또한 컴파일러는 필요한 경우 일부 함수를 임의로 인라인 처리하기도 한다.

## 4. 매크로 함수에는 있지만, 인라인 함수에 없는 장점
- 인라인 함수는 매크로 함수의 장점을 완전히 대체하지 못함
- 매크로 함수가 아래와 같이 정의되면

 #define SQUARE(x)	((x)*(x))

- 이는 자료형에 의존적이지 않은 함수가 된다.

 std::cout<< SQUARE(12);		// int형 함수호출
 std::cout<< SQUARE(3.15);		// double형 함수호출

- 위와 같은 문장울 다음과 같이 변환이 이뤄져 어떠한 경우에도 테이터의 손실이 발생하지 않음

 std::cout <<((12)*(12));	
 std::cout <<((3.15)*(3.15));

- 하지만 다음과 같이 inline 함수가 정의된 경우

 inline int SQUARE(int x) { return x*x; }

- int 형 기반으로 정의된 함수이기 때문에 다음의 함수호출 문장에서 데이터 손실이 발생한다.

 std::cout <<SQUARE(3.15);	// 0.15가 손실되어 3*3의 결과가 나온다.

- 함수의 오버로딩을 통해 문제를 해결할 수 있으나, 여러개의 함수가 추가되어 매크로 함수의 장점과는 거리가 멀어진다.
- 그러나 C++의 Template라는 것을 이용하면 매크로 함수와 마찬가지로 자료형에 의존적이지 않은 함수가 완성됨

EX) Template의 간단한 예

 #include <iostream>

 tmeplate <typename T>
 inline T SQUARE(T x)
 {
	 return x*x;
 }

 int main(void)
 {
	 std::cout<<SQUARE(5.5)<<std::endl;
	 std::cout<<SQUARE(12)<<std::endl;

	 return 0; 
 }